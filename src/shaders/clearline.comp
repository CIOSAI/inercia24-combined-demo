#version 450

/*
 * Kiyo data
 * - WORKGROUP_SIZE and NUM_IMAGES are provided by the engine
 */

layout ( local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;
layout( binding = 0, rgba8 ) uniform image2D images[NUM_IMAGES];
layout( push_constant ) uniform PushConstants
{
    float time;
    int in_image;
    int out_image;
} constants;

/*
 * User data
 */

#define R vec2(imageSize( images[ constants.out_image ] ))

#define pi acos(-1.)
#define tau (acos(-1.)*2.)

#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))

// hashes
uint seed = 12512;
uint hashi( uint x){
    x ^= x >> 16;x *= 0x7feb352dU;x ^= x >> 15;x *= 0x846ca68bU;x ^= x >> 16;
    return x;
}

#define hash_f_s(s)  ( float( hashi(uint(s)) ) / float( 0xffffffffU ) )
#define hash_f()  ( float( seed = hashi(seed) ) / float( 0xffffffffU ) )
#define hash_v2()  vec2(hash_f(),hash_f())
#define hash_v3()  vec3(hash_f(),hash_f(),hash_f())
#define hash_v4()  vec3(hash_f(),hash_f(),hash_f(),hash_f())
#define hash_v3_s(s)  ( vec3(hash_f_s(s),hash_f_s(hashi(s)),hash_f_s(hashi(hashi(s)))) )

// https://www.shadertoy.com/view/XlXcW4
vec3 hash3f( vec3 s ) {
  uvec3 r = floatBitsToUint( s );
  r = ( ( r >> 16u ) ^ r.yzx ) * 1111111111u;
  r = ( ( r >> 16u ) ^ r.yzx ) * 1111111111u;
  r = ( ( r >> 16u ) ^ r.yzx ) * 1111111111u;
  return vec3( r ) / float( -1u );
}

vec2 sample_disk(){
    vec2 r = hash_v2();
    return vec2(sin(r.x*tau),cos(r.x*tau))*sqrt(r.y);
}

uint seed_gen(vec3 p){
    return uint(p.x+66341.)*666562+uint(p.y+54324.)*3554+uint(p.z+61441.);
}

vec3 noise(vec3 p){
    vec3 bl_back = hash3f(floor(p));
    vec3 br_back = hash3f(floor(p)+vec3(1,0,0));
    vec3 tr_back = hash3f(floor(p)+vec3(1,1,0));
    vec3 tl_back = hash3f(floor(p)+vec3(0,1,0));
    vec3 bl_front = hash3f(floor(p)+vec3(0,0,1));
    vec3 br_front = hash3f(floor(p)+vec3(1,0,1));
    vec3 tr_front = hash3f(floor(p)+vec3(1,1,1));
    vec3 tl_front = hash3f(floor(p)+vec3(0,1,1));
    return 
    mix(
    mix(
    mix(bl_back, br_back, smoothstep(0.,1.,fract(p.x))),
    mix(tl_back, tr_back, smoothstep(0.,1.,fract(p.x))),
    smoothstep(0.,1.,fract(p.y))
    ),
    mix(
    mix(bl_front, br_front, smoothstep(0.,1.,fract(p.x))),
    mix(tl_front, tr_front, smoothstep(0.,1.,fract(p.x))),
    smoothstep(0.,1.,fract(p.y))
    ),
    smoothstep(0.,1.,fract(p.z))
    )
    ;
}

// point projection
ivec2 proj_p(vec3 p){
  p *= 0.6;
  
  // depth of field
  p.xy += sample_disk() * abs(p.z - 5.)*0.04;
  
  // convert point to ivec2. From 0 to resolution.xy
  ivec2 q = ivec2((p.xy + vec2(R.x/R.y,1)*0.5)*vec2(R.y/R.x,1)*R);
  if(any(greaterThan(q, ivec2(R))) || any(lessThan(q, ivec2(0)))){
      q = ivec2(-1);
  }
  return q;
}


void store_pixel(ivec2 px_coord, vec3 col){
  // colour quantized to integer.
  ivec3 quant_col = ivec3(col * 1000);
  // no clue why it wants ivec4() here...
  imageStore(images[ constants.out_image ], px_coord, vec4(col,1)); 
}

// void add_to_pixel(ivec2 px_coord, vec3 col){
//   // colour quantized to integer.
//   ivec3 quant_col = ivec3(col * 1000);
//   imageAtomicAdd(images[ constants.out_image ], px_coord, vec4(col,1)); 
// }

vec3 read_pixel(ivec2 px_coord){
  return imageLoad(images[ constants.in_image ], px_coord).rgb; 
}

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

//          â†“ try change this around (0.-.5)
const float B=.3; //bevel amount
const mat2 SEGMENTS[] = mat2[](
    //                                  0x.....0
    mat2(vec2(-1,1.-B),vec2(-1,-1)),    //  left
    mat2(vec2(B-1.,1),vec2(.5,1)),      //  top(l)
    mat2(vec2(.5,1),vec2(1,1)),         //  top(r)
    mat2(vec2(1,1),vec2(1,0)),          //  right(t)
    //                                  0x....0.
    mat2(vec2(1,0),vec2(1,B-1.)),       //  right(b)
    mat2(vec2(1.-B,-1),vec2(-1,-1)),    //  bottom
    mat2(vec2(0,1),vec2(0,-1)),         //  vertical
    mat2(vec2(.5,0),vec2(-1,0)),        //  horizontal(l)
    //                                  0x...0..
    mat2(vec2(.5,0),vec2(1,0)),         //  horizontal(r)
    mat2(vec2(.5,1),vec2(.5,0)),        //  B R
    mat2(vec2(.5,1),vec2(1,0)),         //  D
    mat2(vec2(B-1.,1),vec2(1.-B,-1)),   //  N
    //                                  0x..0...
    mat2(vec2(-1,1.-B),vec2(1.,B-1.)),  //  S
    mat2(vec2(-1,1.-B),vec2(1.-B,-1.)), //  V
    mat2(vec2(1,1),vec2(-1,-1)),        //  Z
    mat2(vec2(1,1),vec2(0,0)),          //  Y K tr
    //                                  0x.0....
    mat2(vec2(-1,1.-B),vec2(0,0)),      //  Y tl
    mat2(vec2(0,0),vec2(0,-1)),         //  vertical(b)
    mat2(vec2(1,1),vec2(-1,-1)),        //  X Z tr bl diag
    mat2(vec2(-1,0),vec2(-1,-1)),       //  left(b)
    //                                  0x0.....
    mat2(vec2(-1,1.-B),vec2(-1,0)),     //  left(t)
    mat2(vec2(0,-.99),vec2(0,-1)),      //  dot
    mat2(vec2(0,1),vec2(0,0)),          //  vertical(t)
    //                                  FROM CONTEXT
    mat2(vec2(-1,1.-B),vec2(B-1.,1)),   //  bevel tl
    mat2(vec2(1,B-1.),vec2(1.-B,-1))    //  bevel br
);  const int BEVEL_TL=SEGMENTS.length()-2, BEVEL_BR=SEGMENTS.length()-1;
const int font[] = int[](
    0x00103F,0x000040,0x0801AE,0x0001BE,0x100198,
    0x1001B6,0x0001B1,0x00001E,0x0001BF,0x10019E,
    0x000000,0x000000,0x000000,0x000000,0x000000, //yet to be decided
    0x208006,0x600000,
    0x00019F,0x0003B3,0x000027,0x000433,0x0000A7,0x000087,
    0x000137,0x000199,0x000066,0x00003E,0x008191,0x000021,
    0x00005F,0x000819,0x00003F,0x00018F,0x02003F,0x000393,
    0x001026,0x000046,0x000039,0x002018,0x000079,0x004800,
    0x038000,0x004026
);
int ascii_to_bitmask(int i){
    int l=font[i-48];
    if((l&0x13813)!=0) l+= 1<<BEVEL_TL;
    if((l&0x03830)!=0) l+= 1<<BEVEL_BR;
    return l;
}

float sdSegment( in vec2 p, in vec2 a, in vec2 b )
{
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}
float letter(vec3 p, int ascii)
{
    float accum=9999.;
    for(int j=0;j<SEGMENTS.length();j++){
        if((ascii_to_bitmask(ascii)&(1<<j))!=0){
            float seg = sdSegment(vec2(p.x,-p.y),SEGMENTS[j][0],SEGMENTS[j][1]);
            accum=min(accum,seg);
        }
    }
    
    return accum;
}

vec3 fbm(vec3 p)
{
    float retain = .4;
    vec3 acc = p;
    for(int i=0; i<4; i++){
        acc = noise(acc*float(1+i)*1.4) * pow(retain,float(i));
    }
    return acc;
}

void main()
{
    ivec2 p = ivec2( gl_GlobalInvocationID.xy );
    ivec2 screenSize = imageSize( images[ constants.out_image ] );
    if( p.x > screenSize.x || p.y > screenSize.y )
    {
        return;
    }

    vec2 uv = (vec2(p) - .5*R)/R.y;

    if( p.x < 100 ){
        seed = uint(p.y*R.x+p.x);

        // { wave }
            float time = constants.time*.3;

            float pattern = hash_f();
            if (pattern<.3){
                vec3 pos = vec3((hash_f()*2.-1.)*2.,0,0);
                pos.y = (noise(pos.xxx*8.-time*4.).x*2.-1.)*.5;
                pos*=.75;

                vec3 col = vec3(.4,.8-length(pos),.3+length(pos)*.2);
                col = hsv2rgb(col);
                store_pixel(proj_p(pos+vec3(0,0,8.5)), col);
            }
            else if(pattern<.4){
                vec3 pos = vec3(0);
                for(int i=0; i<128; i++){
                    float accum = 9999.;
                    int text[] = {67,73,79,83,65,73};
                    for(int j=0; j<6; j++){
                        vec3 off = vec3((float(j)-2.5)*3.,0,0);
                        float l = letter(pos*10.-off, text[j]);

                        if(fract(time*4.-float(j)/6.)<.1*step(.5,sin(time*6.))){
                            vec2 q = abs(pos*10.-off).xy;
                            l = max(q.x,q.y)-1.;
                        }

                        accum = min(accum,l);
                    }
                    if ( accum < .1 ) { break; }
                    pos.xy = hash_v2()*2.-1.;
                }

                pos *= .5;
                pos.xy += vec2(-1.,.6);

                vec3 col = vec3(.4,.8-length(pos),.3+length(pos)*.2);
                col = hsv2rgb(col);
                store_pixel(proj_p(pos+vec3(0,0,8.5)), col);
            }
            else if(pattern<.5){
                vec3 pos = vec3(hash_f()*2.-1.,hash_f()*2.-1.,0);
                
                vec2 ghost = vec2(cos(time*3.),sin(time*4.));
                if(hash_f()<.2){
                    pos.xy = mix(pos.xy,ghost,.9);
                }

                float lines = 3.;
                if(hash_f()<.5){
                    pos.x = round(pos.x*lines)/lines;
                }
                else{
                    pos.y = round(pos.y*lines)/lines;
                }

                pos *= .35;
                pos.xy += vec2(-1.,-.5);

                vec3 col = vec3(.4,.8-length(pos),.3+length(pos)*.2);
                col = hsv2rgb(col);
                store_pixel(proj_p(pos+vec3(0,0,8.5)), col);
            }
            else if(pattern<1.){
                vec3 pos;
                vec2 scaling = vec2(.5,.2);
                if(hash_f()<.5){
                    pos = vec3(hash_f()*2.-1.,step(.5,hash_f())*2.-1.,0);
                    if(hash_f()<.5) { pos.xy = pos.yx; }
                    
                }
                else{
                    pos = vec3(0);
                    for(int i=0; i<128; i++){
                        vec2 n_uv = pos.xy/scaling.yx;
                        float acc;
                        acc += sqrt(length(n_uv-(noise(vec3(time,0,0)*2.).xy*2.-1.)*3.));
                        acc += sqrt(length(n_uv-(noise(vec3(0,time,0)*2.).xy*2.-1.)*3.));
                        acc += sqrt(length(n_uv-(noise(vec3(0,0,time)*2.).xy*2.-1.)*3.));
                        acc += sqrt(length(n_uv-(noise(vec3(time,0,-time)*2.).xy*2.-1.)*3.));
                        if ( abs(acc-7.) < .1 ) { break; }
                        pos.xy = hash_v2()*2.-1.;
                    }
                }
                pos.xy *= scaling;
                pos.xy += vec2(.75,.5);

                vec3 col = vec3(.4,.8-length(pos),.3+length(pos)*.2);
                col = hsv2rgb(col);
                store_pixel(proj_p(pos+vec3(0,0,8.5)), col);
            }
        // { wave }
    }
}